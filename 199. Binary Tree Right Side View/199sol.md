# Intuition
The problem asks for the right side view of a binary tree, which means we need to return the last node at each level of the tree when viewed from the right side.

# Approach
To solve this problem, we can use a level-order traversal (BFS) of the tree. We'll traverse the tree level by level and at each level, add the last node's value to our result. We'll use a queue to perform level-order traversal. At each level, we'll keep track of the size of the current level so that we know when we've finished traversing that level. We'll then add the value of the last node in that level to our result.

# Complexity
- Time complexity: $$O(n)$$, where \(n\) is the number of nodes in the binary tree. We visit each node once.
- Space complexity: $$O(n)$$, where \(n\) is the number of nodes in the binary tree. In the worst case, the queue can hold all nodes at the lowest level.

# Code
```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> ans; // To store the result
        queue<TreeNode*> q; // Queue for level order traversal
        
        if (root == nullptr) // If the tree is empty
            return ans;
        
        q.push(root); // Push the root node
        
        while (!q.empty()) { // While there are nodes in the queue
            int size = q.size(); // Size of the current level
            
            // Traverse the current level
            for (int i = 0; i < size; ++i) {
                TreeNode* temp = q.front(); // Get the front node
                q.pop(); // Remove the front node
                
                // If it's the last node at this level, add its value to the result
                if (i == size - 1) 
                    ans.push_back(temp->val);
                
                // Add its children to the queue
                if (temp->left != nullptr)
                    q.push(temp->left);
                if (temp->right != nullptr)
                    q.push(temp->right);
            }
        }
        
        return ans;
    }
};
```

In the code:
- We maintain a queue `q` for level-order traversal.
- We initialize the queue with the root node.
- We iterate until the queue is empty, which means we have traversed all nodes.
- Inside the loop, we get the size of the current level, and iterate through all nodes of this level.
- We add the value of the last node of each level to the result vector `ans`.
- We push the children of each node into the queue if they exist.